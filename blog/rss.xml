<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Sergey Gromkov Blog</title>
        <link>https://gromkov.me/blog</link>
        <description>Sergey Gromkov Blog</description>
        <lastBuildDate>Thu, 02 Dec 2021 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[«Чистая архитектура»: про три подхода к решению задач]]></title>
            <link>https://gromkov.me/blog/2021/12/02/clean-architecture-about-about-three-approaches-to-solving-problems</link>
            <guid>«Чистая архитектура»: про три подхода к решению задач</guid>
            <pubDate>Thu, 02 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Три шага]]></description>
            <content:encoded><![CDATA[<h2>Три шага</h2><p>Мартин ссылается на другого программиста, рассказывая о трех шагах, как писать хороший код:</p><figure><blockquote><p>Кент Бек описывает три шага в создании программного обеспечения:</p><ol><li>«Сначала заставьте его работать». <em>Вы останетесь не у дел, если он не заработает.</em></li><li>«Затем перепишите его правильно». <em>Реорганизуйте код, чтобы вы и другие смогли понимать и развивать его, когда потребуется что-то изменить или понять.</em></li><li>«Затем заставьте его работать быстро». <em>Реорганизуйте код, чтобы добиться «необходимой» производительности.</em></li></ol></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><h2>Планирование рефакторинга</h2><p>Несколько экспертов сходятся во мнении, что нужно планировать выбросить первую версию продукта, и писать вторую, лучшую:</p><figure><blockquote><p>Большая часть встраиваемых чистем, которые мне приходилось видеть, похоже писалась с единственной мыслью в голове: «Заставьте его работать», — и иногда навязчивой идеей: «Заставьте его работать быстро», — воплощаемой введением микрооптимизаций при каждом удобном случае. В своей первой книге <em>The Mythical Man-Month</em> Фред Брукс предлагает «планировать отказ от первой версии». Кент и Фред советуют одно и то же: узнайте, как это работает, и найдите лучшее решение.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><h2>Тест на профпригодность</h2><p>Про профессионализм программистов:</p><figure><blockquote><p>Получение работающего приложения — это то, что я называю тестом на профпригодность для программиста. Программист, разрабатывающий программное обеспечение, встраиваемое или нет, который заботится только о том, чтобы получить работающее приложение, наносит вред своим продуктам и работодателю. Программирование — это нечто большее, чем умение писать работающие приложения.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[«Чистая архитектура»: про дублирование кода]]></title>
            <link>https://gromkov.me/blog/2021/11/30/clean-architecture-about-code-duplication</link>
            <guid>«Чистая архитектура»: про дублирование кода</guid>
            <pubDate>Tue, 30 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Знал бы я три года назад, что не каждое дублирование нужно устранять, сэкономил бы кучу времени своей команды и команды тестировщиков. Расскажу одну историю.]]></description>
            <content:encoded><![CDATA[<p>Знал бы я три года назад, что не каждое дублирование нужно устранять, сэкономил бы кучу времени своей команды и команды тестировщиков. Расскажу одну историю.</p><h2>Пример из практики</h2><p>Был у нас в matchtv.ru маленький компонент с счетом футбольного матча и названиями играющих команд. Этот компонент использовался в десятках мест на сайте, и везде выглядел немножко иначе:</p><table><thead><tr><th align="left">Светлая тема</th><th align="left">Темная тема</th></tr></thead><tbody><tr><td align="left"><img src="1.png"/></td><td align="left"><img src="4.png"/></td></tr><tr><td align="left"><img src="2.png"/></td><td align="left"><img src="6.png"/></td></tr><tr><td align="left"><img src="3.png"/></td><td align="left"><img src="7.png"/></td></tr><tr><td align="left"><img src="5.png"/></td><td align="left"><img src="8.png"/></td></tr></tbody></table><p>Компонент изначально казался таким простым, что при каждом новом запросе от бизнеса мы добавляли условия в коде компонента и немного меняли его поведение:</p><ul><li>Выводить ли полную дату или только время?</li><li>А может вообще не показывать дату?</li><li>Логотип команды справа или слева от названия команды?</li><li>Отображать пенальти или нет?</li><li>Показывать страну команды или нет?</li><li>А шрифт большой или маленький?</li><li>А крестик у будущего матча вместо счета или прочерки?</li></ul><p>В итоге компонент из 30 строк разросся до 300, и каждая новая правка для матча на одной странице ломала отображение матча на других страницах. И тогда мы создали независимую копию компонента для каждой конкретной задачи, чтобы наши правки не ломали матчи.</p><h2>Мнение эксперта</h2><p>Вот, что Роберт Мартин говорит об этом в своей книге:</p><figure><blockquote><p>Архитекторы часто попадают в ловушку, зависящую от их страха перед дублированием.</p><p>Вообще в программном обеспечении считается, что дублирования следует избегать. Мы стараемся предотвратить дублирование программного кода. Когда обнаруживается действительно повторяющийся код, мы с благоговением смотрим, как профессионалы устраняют его.</p><p>Но есть разные виды дублирования. Есть истинное дублирование, когда любое изменение в одной копии требует того же изменения во всех остальных копиях. А есть ложное дублирование. Если два фрагмента кода, кажущиеся одинаковыми, развиваются разными путями — если они изменяются с разной скоростью и по разным причинам — этот случай не является истинным дублированием. Вернитесь к ним через несколько лет, и вы увидите, что они совершенно не похожи друг на друга.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[«Чистая архитектура»: про принципы SOLID]]></title>
            <link>https://gromkov.me/blog/2021/11/29/clean-architecture-about-solid-principles</link>
            <guid>«Чистая архитектура»: про принципы SOLID</guid>
            <pubDate>Mon, 29 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Свою «чистую архитектуру» Роберт Мартин строит на принципах SOLID, которые он же и придумал. Эти принципы очень популярны в объектно-ориентированном программировании.]]></description>
            <content:encoded><![CDATA[<p>Свою «чистую архитектуру» Роберт Мартин строит на принципах SOLID, которые он же и придумал. Эти принципы очень популярны в объектно-ориентированном программировании.</p><h2>Зачем нам SOLID</h2><p>Мартин не идиализирует свои принципы, а видит их, как хорошое компромиссное решение для построения архитектуры:</p><figure><blockquote><p>Хорошая программная система начинается с чистого кода. С одной стороны, если здание строить из плохих кирпичей, его архитектура не имеет большого значения. С другой стороны, плохие кирпичи можно перемешать с хорошими. Именно на этом основаны принципы SOLID.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><p>SOLID это не только про ООП:</p><figure><blockquote><p>Принципы SOLID определяют, как объединять функции и структуры данных в классы и как эти классы должны сочетаться друг с другом. Использование слова «класс» не означает, что эти принципы применимы только к объектно-ориентированному программному коду. В данном случае «класс» означает лишь инструмент объединения функций и данных в группы. Любая программная система имеет такие объединения, как бы они ни назывались, «класс» или как-то еще. Принципы SOLID применяются к этим объединениям.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><h2>Пять китов ООП</h2><h3>Принцип единственной ответственности</h3><p>«Единственная ответственность» — это не про обязанность класса делать что-то одно, а про группу заинтересованных лиц (актора), для которой работает класс:</p><figure><blockquote><p>SRP: Single Responsibility Principle — принцип единственной ответственности.</p><p>Лучшей является такая структура программной системы, которая формируется в основном под влиянием социальной структуры организации, использующей эту систему, поэтому каждый программный модуль имеет одну и только одну причину для изменения.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><p>Как многие ошибочно трактуют этот принцип:</p><figure><blockquote><p>Из всех принципов SOLID наиболее труднопонимаемым является принцип единственной ответственности (Single Responsibility Principle, SRP). Это, вероятно, обусловлено выбором названия, недостаточно точно соответствующего сути. Услышав это название, многие программисты решают: оно означает, что каждый модуль должен отвечать за что-то одно.</p><p>Самое интересное, что такой принцип <em>действительно</em> существует. Он гласит: <em>функция</em> должна делать что-то одно и только одно. Этот принцип мы используем, когда делим большие функции на меньшие, то есть на более низком уровне. Но он не является одним из принципов SOLID — это не принцип единственной ответственности.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><p>Что на самом деле он значит:</p><figure><blockquote><p>Традиционно принцип единственной ответственности описывался так: <em>модуль должен иметь одну и только одну причину для изменения.</em></p><p>Программное обеспечение изменяется для удовлетворения нужд пользователей и заинтересованных лиц. Пользователи и заинтересованные лица как раз и есть <em>та самая</em> «причина для изменения», о которой говорит принцип.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><p>Пример:</p><table><thead><tr><th align="left">❌ Не правильно</th><th align="left">✅ Правильно</th></tr></thead><tbody><tr><td align="left"><img src="1.jpg" alt="Неправильная реализация класса Employee, потому что ему принадлежат методы для разных отделов"/><br/><img src="2.jpg" alt="Два метода класса используют одну и ту же функцию, что приводит к ошибкам"/></td><td align="left"><img src="3.jpg" alt="Правильная реализация классов, где каждый класс подчиняется собственному отделу"/></td></tr></tbody></table><h3>Принцип открытости/закрытости</h3><figure><blockquote><p>OCP: Open-Closed Principle — принцип открытости/закрытости.</p><p>Простая для изменения система должна предусматривать простую возможность изменения ее поведения добавлением нового, но не изменением существующего кода.</p><p>Этот принцип гласит: <em>программные сущности должны быть открыты для расширения и закрыты для изменения.</em></p><p>Иными словами, должна иметься возможность расширять поведение программных сущностей без их изменения.</p><p>Принцип открытости/закрытости — одна из движущих сил в архитектуре систем. Его цель — сделать систему легко расширяемой и обезопасить ее от влияния изменений. Эта цель достигается делением системы на компоненты и упорядочиванием их зависимостей в иерархию, защищающую компоненты уровнем выше от изменений в компонентах уровнем ниже.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><h3>Принцип подстановки Барбары Лисков</h3><figure><blockquote><p>LSP: Liskov Substitution Principle — принцип подстановки Барбары Лисков</p><p>Для создания программных систем из взаимозаменяемых частей эти части должны соответствовать контракту, который позволяет заменять эти части друг другом.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><h3>Принцип разделения интерфейсов</h3><figure><blockquote><p>ISP: Interface Segregation Principle — принцип разделения интерфейсов.</p><p>Этот принцип призывает разработчиков программного обеспечения избегать зависимости от всего, что не используется.</p><p>Опасно создавать зависимости от модулей, содержащих больше, чем требуется. Зависимости, несущие лишний груз ненужных и неиспользуемых особенностей, могут стать причинной неожиданных проблем.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><h3>Принцип инверсии зависимости</h3><figure><blockquote><p>DIP: Dependency Inversion Principle — принцип инверсии зависимости.</p><p>Код, реализующий высокоуровневую политику, не должен зависеть от кода, реализующего низкоуровневые детали. Напротив, детали должны зависеть от политики.</p><p>Этот принцип утверждает, что наиболее гибкими получаются системы, в которых зависимости в исходном коде направлены на абстракции, а не на конкретные реализации.</p><p>В языках со статической системой типов, таких как Java, это означает, что инструкции use, import и include должны ссылаться только на модули с исходным кодом, содержащим интерфейсы, абстрактные классы и другие абстрактные объявления. Никаких зависимостей от конкретных реализаций не должно быть.</p><p>То же правило действует для языков с динамической системой типов, таких как Ruby или Python. Исходный код не должен зависеть от модулей с конкретной реализацией. Однако в этих языках труднее определить, что такое конкретный модуль. В частности, это любой модуль, в котором реализованы вызываемые функции.</p><p>Мы должны избегать зависимости от модулей, которые продолжают активно разрабатываться и претерпевают частые изменения.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[«Чистая архитектура»: про плохую архитектуру]]></title>
            <link>https://gromkov.me/blog/2021/11/27/clean-architecture-about-bad-architecture</link>
            <guid>«Чистая архитектура»: про плохую архитектуру</guid>
            <pubDate>Sat, 27 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Роберт Мартин уверен, что плохая архитектура обязательно приведет проект в тупик: стоимость поддержки одной строки кода будет бесконечно расти, а мотивация программистов падать. В главе «Что такое дизайн и архитектура» он описывает последствия некачественной архитектуры.]]></description>
            <content:encoded><![CDATA[<p>Роберт Мартин уверен, что плохая архитектура обязательно приведет проект в тупик: стоимость поддержки одной строки кода будет бесконечно расти, а мотивация программистов падать. В главе «Что такое дизайн и архитектура» он описывает последствия некачественной архитектуры.</p><h2>Предпосылки плохой архитектуры</h2><figure><blockquote><p>Когда системы создаются второпях, когда увеличение штата программистов — единственный способ продолжать выпускать новые версии и когда чистоте кода или дизайну уделяется минимум внимания или не уделяется вообще, можно даже не сомневаться, что такая тенденция рано или поздно приведет к краху.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><h2>Последствия плохой архитектуры</h2><p>В качестве примера последствий плохой архитектуры продукта Роберт Мартин приводит три графика:</p><table><thead><tr><th align="left">Рост количества программистов</th><th align="left">Рост продуктивности</th><th align="left">Рост стоимости одной строки кода</th></tr></thead><tbody><tr><td align="left"><img src="1.jpg" alt="на графике количество сотрудников быстро растет"/></td><td align="left"><img src="2.jpg" alt="на графике продуктивность слабо увеличивается"/></td><td align="left"><img src="3.jpg" alt="на графике стоимость одной строки кода быстро увеличивается"/></td></tr></tbody></table><p>Получается, что с ростом кодовой базы с плохой архитектурой продуктивность работы сотрудников падает, и компании обходится всё дороже поддержка кода:</p><figure><blockquote><p>Эта тенденция говорит о нежизнеспособности. Какой бы рентабельной ни была компания в настоящее время, растущие накладные расходы поглотят прибыль и приведут ее к застою, если не к краху.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><h2>Почему разработчики пишут плохой код</h2><p>Чаще всего по двум причинам: из-за нехватки опыта, или из-за ограниченных сроков. В случае ограниченных сроков, Роберт Мартин описывает подход программистов так:</p><figure><blockquote><p>Разработчики верят в известную ложь: «Мы сможем навести порядок потом, нам бы только выйти на рынок!». В результате порядок так и не наводится, потому что давление конкуренции на рынке никогда не ослабевает. Выход на рынок означает, что теперь у вас на хвосте висят конкуренты и вы должны стремиться оставаться впереди них и бежать вперед изо всех сил.</p><p>Программисты не могут вернуться и навести порядок, потому что должны реализовать следующую новую функцию, а потом еще одну, и еще, и еще. В результате беспорядок нарастает, а продуктивность стремится к своему пределу около нуля.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><p>Еще немного про грязный код и продуктивность:</p><figure><blockquote><p>Самая большая ложь, в которую верят многие разработчики, — что грязный код поможет им быстро выйти на рынок, но в действительности он затормозит их движение в долгосрочной перспективе.</p><p>Дело в том, что создание беспорядка всегда оказывается медленнее, чем неуклонное соблюдение чистоты.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><h2>Что же делать</h2><p>Нужно стараться изо всех сил держать код в порядке, и выделять время на рефакторинг и наведение чистоты:</p><figure><blockquote><p>Единственный способ обратить вспять снижение продуктивности и увеличение стоимости — заставить разработчиков начать нести ответственность за беспорядок, который они учинили.</p><p>Разработчики могут подумать, что проблему можно исправить, только начав все с самого начала и перепроектировав всю систему целиком, — но это в них говорит самонадеянность. Самонадеянность, управляющая перепроектированием, приведет к тому же беспорядку, что и прежде.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[«Чистая архитектура»: про разницу между работающими и правильными программами]]></title>
            <link>https://gromkov.me/blog/2021/11/26/clean-architecture-about-the-difference-between-working-and-correct-programs</link>
            <guid>«Чистая архитектура»: про разницу между работающими и правильными программами</guid>
            <pubDate>Fri, 26 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Книга «Чистая архитектура» начинается с мнения Роберта Мартина о разнице между работающими и правильными программами, и теми преимуществами, которыми обладают вторые.]]></description>
            <content:encoded><![CDATA[<p>Книга «Чистая архитектура» начинается с мнения Роберта Мартина о разнице между работающими и правильными программами, и теми преимуществами, которыми обладают вторые.</p><h2>Про работающие программы</h2><figure><blockquote><p>Чтобы написать действующую программу, не нужно много знать и уметь. Начинающие программисты пишут не самый лучший код, но он работает. Он работает, потому что заставить что-то работать — один раз — не очень сложно.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><p>Передаю привет 🙋‍♂️ моим первым сорока сайтам, что я сделал в Рокет Студии. Простите меня 🫂, я был молод и делал всё, что мог.</p><h2>Про правильные программы</h2><figure><blockquote><p>Создать программу, которая будет работать правильно, — совсем другое дело. Написать правильную программу сложно. Для этого необходимы знания и умения, которые молодые специалисты еще не успели приобрести. А чтобы приобрести их, требуется мыслить и анализировать, на что у многих программистов просто нет времени. Это требует такой самодисциплины и организованности, которые не снились большинству программистов. А для этого нужно испытывать страсть к профессии и желание стать профессионалом.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><p>Связь между созданием правильных программ и желанием стать профессионалом может показаться не очевидной. В другой своей книге,  «Идеальный программист», Мартин описывает, как страсть к профессии кореллирует с созданием качественных программ.</p><p>Далее о преимуществах качественных программ:</p><figure><blockquote><p>Но когда создается правильный программный код, происходит что-то необычное: вам не требуются толпы программистов для поддержки его работоспособности. Вам не нужна объемная документация с требованиями и гигантские баг-трекеры. Вам не нужны огромные опенспейсы, работающие круглые сутки без выходных.</p><p>Правильный программный код не требует больших трудозатрат на свое создание и сопровождение. Изменения вносятся легко и быстро. Ошибки немногочисленны. Трудозатраты минимальны, а функциональность и гибкость — максимальны.</p></blockquote><figcaption>— Р. Мартин, <cite>«Чистая архитектура»</cite></figcaption></figure><h2>Выводы</h2><p>Я согласен с автором, что для создания качественного ПО необходимо, как минимум, испытывать любовь к программированию, и иметь желание развиваться в этой сфере, как профессионал. О разнице между профессионалом и специалистом Роберт Мартин пишет в книге «Идеальный программист».</p><p>В моей практике качеством программного кода зачастую жертвуют компании-подрядчики, создающие программы для заказчиков. Повысить шансы на успешную разработку правильных программ можно перенося команду разработки внутрь продуктовой компании.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Меняем стул под пользователем]]></title>
            <link>https://gromkov.me/blog/2021/10/15/changing-the-chair-under-the-user</link>
            <guid>Меняем стул под пользователем</guid>
            <pubDate>Fri, 15 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Мысли после просмотра доклада Александра Коротаева «Меняем стул под пользователем».]]></description>
            <content:encoded><![CDATA[<p>Мысли после просмотра доклада Александра Коротаева «Меняем стул под пользователем».</p><div class="video"><iframe width="966" height="543" src="https://www.youtube.com/embed/W5YXcI3ov4w" frameBorder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Ссылка на видео: <a href="https://www.youtube.com/watch?v=W5YXcI3ov4w">https://www.youtube.com/watch?v=W5YXcI3ov4w</a></p><p>Александр Коротаев рассказал о том, как работает раскатка релизов во ВКонтакте, и с какой болью ему пришлось столкнуться сменив однажды адрес статики.</p><h2>Trunk based development</h2><p>Я же впервые услышал о таком подходе к релизам, как «Trunk base development». Это когда берется trunk-ветка, чаще всего она будет называться master или main, и автоматически релизится, то есть выкатывается в прод, через какое-то небольшое количество времени, а все разработчики вливают фичи, баги и хотфиксы прямо в trunk-ветку. Нет ручного сбора задач в один релиз. Вместо этого задачи попадают в релизы хаотично: какие успели влить в trunk-ветку до релиза, те и выльются в продакшен.</p><p>В случае со ВКонтакте, релизы происходят каждые 30 минут, а trunk-ветка называется master. И кто успел вмержить свой код в master перед релизом, тот и попадет в продакшен. А через полчаса можно вылить хотфикс или откатить сломанный код.</p><p>Вы только представьте, любую фичу можно выкатить в продакшен буквально спустя час после того, как вы ее реализовали. Александр Коротаев называет эту метрику «Time to market». И если что-то сломалось после релиза, то оно также быстро чинится следующим релизом через 30 минут. Не чудо ли?</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Как бороться с багами без боли и агрессии]]></title>
            <link>https://gromkov.me/blog/2021/10/14/how-to-deal-with-bugs-without-pain-and-aggression</link>
            <guid>Как бороться с багами без боли и агрессии</guid>
            <pubDate>Thu, 14 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Мысли после просмотра доклада Алексея Попкова «Как бороться с багами без боли и агрессии».]]></description>
            <content:encoded><![CDATA[<p>Мысли после просмотра доклада Алексея Попкова «Как бороться с багами без боли и агрессии».</p><div class="video"><iframe width="966" height="543" src="https://www.youtube.com/embed/50DmBnR0oLc" frameBorder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Ссылка на видео: <a href="https://www.youtube.com/watch?v=50DmBnR0oLc">https://www.youtube.com/watch?v=50DmBnR0oLc</a></p><p>Алексей Попков рассказал о своих подходах к фиксу багов в большом приложении.</p><p>Я же себе пометил мысль:</p><p>:::tip
Если у вас есть инструкция, как выкатить релиз, рядом с ней должна быть и как откатить.
:::</p><blockquote><p>Багов в проде, конечно же, не боимся. Если вдруг у вас еще нет инструкции, как откатить релиз, обязательно ее сделайте. Если у вас есть инструкция, как выкатить релиз, рядом с ней должна быть и как откатить. Потому что часто эти два процесса происходят вот как в инструкции: ты читаешь сверху вниз, выкатываешь релиз, и продолжаешь читать откат релиза, выполняя его прям также по пунктам.</p></blockquote>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Ошибки хороших руководителей]]></title>
            <link>https://gromkov.me/blog/2021/10/13/mistakes-of-good-managers</link>
            <guid>Ошибки хороших руководителей</guid>
            <pubDate>Wed, 13 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Важное из доклада Натальи Ёркиной «Ошибки хороших руководителей».]]></description>
            <content:encoded><![CDATA[<p>Важное из доклада Натальи Ёркиной «Ошибки хороших руководителей».</p><div class="video"><iframe width="966" height="543" src="https://www.youtube.com/embed/g2aYs0UwxYU" frameBorder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Ссылка на видео: <a href="https://www.youtube.com/watch?v=g2aYs0UwxYU">https://www.youtube.com/watch?v=g2aYs0UwxYU</a></p><p>Наталья Ёркина поделилась своим опытом руководства фронтенд-командой в Островке: так ли нужны встречи 1-на-1, и как безболезненно делегировать задачи.</p><h2>Встречи 1-на-1</h2><h3>Плюсы</h3><ol><li>Способ узнать, что думает и чувствует сотрудник;</li><li>Растет взаимопонимание и доверие;</li><li>Получение двусторонней обратной связи.</li></ol><h3>Минусы</h3><ol><li>Однообразные беседы выматывают;</li><li>Подготовка занимает много рабочего времени;</li><li>Часто встречи навязываются, потому что «надо»;</li><li>Встречи ничего не меняют.</li></ol><h3>Альтернативы</h3><ol><li>Создать чаты, куда каждый может писать всё, что его беспокоит;</li><li>Еженедельные групповые встречи;</li><li>Давать обратную связь сразу же;</li><li>Задавать уточняющие вопросы если видим, что что-то не так;</li><li>Учитывать мнение сотрудника.</li></ol><h3>Почему чат может сработать</h3><ol><li>Эмоциональное высказывание помогает прожить проблему;</li><li>Просто и удобно участвовать - руководителю не нужно навязывать этот инструмент.</li></ol><h3>Выводы</h3><ol><li>Встречи 1-на-1  нужны в случаях, когда руководитель не 24/7 в команде;</li><li>Можно с кем-то проводить, а с кем-то нет.</li></ol><h2>Делегирование</h2><h3>Плюсы</h3><ol><li>Формируется кадровый резерв;</li><li>Освобождается время под более важные задачи;</li><li>Сотрудников мотивируют новые задачи (иногда);</li><li>Повышение «включённости» работников.</li></ol><h3>Минусы</h3><ol><li>Дополнительная работа не приближает сотрудника к должности руководителя;</li><li>Сотрудника перегружают работой, которая не относится к его обязанностям;</li><li>Руководители сваливают на подчиненных не интересную работу;</li><li>Убивается мотивация;</li><li>Провоцируются увольнения из-за потери комфортного места работы.</li></ol><h3>Что делать</h3><ol><li>Не брать себе и не давать другим много работы;</li><li>Отдавать работу, которую сотрудники сами хотят взять;</li><li>Если добавили обязанностей сотруднику, то что-то нужно забрать у него часть других обязанностей.</li></ol><h3>Выводы</h3><ol><li>Не перегружая себя и команду мы избегаем «выгорания»;</li><li>Комфортное место работы может быть важнее другой мотивации.</li></ol>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Что я хотела бы знать о Докере до того, как начала его использовать]]></title>
            <link>https://gromkov.me/blog/2021/08/31/things-i-wish-i-knew-about-docker-before-i-started-using-it</link>
            <guid>Что я хотела бы знать о Докере до того, как начала его использовать</guid>
            <pubDate>Tue, 31 Aug 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Это перевод статьи из блога TWG инженера-программиста Николь Чанг, в которой она рассказывает о своих впечатлениях о Докере, инструменте для разработчиков, позволяющем упаковывать, отправлять и запускать любое приложение в виде самодостаточного контейнера, который работает где угодно — от ноутбука до любого крупного облачного сервиса.]]></description>
            <content:encoded><![CDATA[<p>:::note Это перевод статьи
Это перевод <a href="https://twg.io/blog/things-i-wish-i-knew-about-docker-before-i-started-using-it/">статьи из блога TWG</a> инженера-программиста Николь Чанг, в которой она рассказывает о своих впечатлениях о Докере, инструменте для разработчиков, позволяющем упаковывать, отправлять и запускать любое приложение в виде самодостаточного контейнера, который работает где угодно — от ноутбука до любого крупного облачного сервиса.
:::</p><p><img src="./docker-1.jpg" alt="Docker ideas"/></p><p>Когда я только начинала изучать Докер, я смотрела его документацию, читала статьи в блогах, листала книги и использовала чужие публичные git-репозитории для справки. Все эти ресурсы не очень-то мне помогли.</p><p>На сайте Stack Overflow я обнаружила, что многие люди задавали те же вопросы, что и я:</p><ol><li>Что такое <code>WORKDIR</code>, где он находится и как он работает на самом деле?</li><li>Почему докер-контейнер не обновляется, когда я меняю <code>Dockerfile</code>? (Как в Докере устроено кеширование?)</li><li>Что такое <em>Docker compose</em>, и зачем мне его использовать?</li><li>Как войти в запущенный контейнер по ssh?</li><li>Куда поместить код и данные, которые должны храниться вне докер-контейнера? Что делать, если мне нужно уничтожить приложение, но сохранить базу данных? (подсказка: <em>Docker volumes</em>)</li></ol><h2>Что такое <code>WORKDIR</code>, где он находится и как он работает на самом деле?</h2><p>Вот пример <code>Dockerfile</code>:</p><pre><code>FROM node:alpine
WORKDIR /usr/src/app
</code></pre><p>Здесь я использую <code>node:alpine</code> как основу для своего образа (это популярный образ из-за своего маленького размера).</p><p>Далее я указываю <code>/usr/src/app</code> в качестве рабочей директории для файлов проекта, которые позже помещу сюда.</p><p>Так вот, <code>WORKDIR</code> это ваша рабочая директория. Она существует только внутри контейнера. По умолчанию Докер создает папку <code>/usr</code>. Так что папка <code>/usr</code> почти всегда будет присутствовать в образе.</p><p>Если вы хотите, чтобы ваша рабочая директория находилась в совсем другой папке, вам нужно сначала создать эту папку:</p><pre><code>FROM node:alpine
MKDIR app
WORKDIR app
</code></pre><p>Чаще всего <code>WORKDIR</code> будет идти сразу после команды <code>FROM</code> в докерфайлах. Это потому что остальные команды в этом файле, такие как <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>, <code>COPY</code> или <code>ADD</code>, будут выполняться уже внутри директории, указанной в <code>WORKDIR</code>.</p><p>На самом деле, единственная команда <code>RUN</code>, которую можно вставить перед командой <code>WORKDIR</code>, — это установка любых зависимостей, которые вы хотели бы видеть глобальными в своем контейнере. Все остальное должно быть в рабочей директории, указанной в <code>WORKDIR</code>.</p><h2>Почему мой докер-контейнер не меняется, когда я меняю <code>Dockerfile</code>? (Как в Докере устроено кеширование?)</h2><p>Каждая команда (строчка) в <code>Dockerfile</code> кешируется. Вообще, кеширование устроено непросто, но если вы посмотрите на логи в командной строке, вы увидите примерно такое:</p><pre><code>Step 2 : RUN npm install -g nodemon
 — -&gt; Using cache
 — -&gt; &lt;some hash goes here&gt;
Step 3 : WORKDIR /app
 — -&gt; Using cache
 — -&gt; &lt;some hash goes here&gt;
Step 4 : COPY package.json .
 — -&gt; &lt;some hash goes here&gt;
Removing intermediate container &lt;some hash goes here&gt;
Step 7 : RUN npm install
 — -&gt; Running in &lt;some hash goes here&gt;
</code></pre><p>Обратите внимание на вот такие строчки:</p><pre><code>— -&gt; Using cache
</code></pre><p>Если ваш код не менялся с того момента, когда вы последний раз изменили свой <code>Dockerfile</code>, и Докер воспользовался закешированными данными, это хорошо. Но что делать, если файлы вашего приложения изменились? Например, если вы установили новые зависимости в <code>package.json</code>, или изменили код в любом из файлов, которые вы ранее скопировали или добавили в контейнер через команды <code>COPY</code> или <code>ADD</code>.</p><p>Смысл кеша в том, чтобы ускорить время сборки. Кеширование отлично подходит для вашего базового образа (см. <code>FROM</code>), поскольку загрузка этого образа занимает много времени, а сами образы меняются очень редко. Однако кеширование может доставить много боли пока вы создаете докер-контейнер.</p><p>Если вы уверены, что не будете менять свой <code>Dockerfile</code> в ближайшие несколько месяцев, можно смело использовать кеширование, но важно понимать, что именно кешируется, иначе вы столкнетесь с неприятными, отнимающими время сюрпризами, когда измените свой код, а в докер-контейнере ничего не изменится.</p><p>Из-за того, как работает кеширование в Докере, вы частенько можете оказаться в ситуации, когда не увидите никаких обновлений после изменения файлов <code>Dockerfile</code> и <code>docker-compose.yml</code>, или кода приложения. Для решения этой проблемы есть несколько полезных команд, приведенных ниже.</p><ul><li>Удалить все докер-контейнеры (нужно запустить до того, как удалять докер-образы):
<code>$ docker rm $(docker ps -aq)</code></li><li>Удалить все докер-образы:
<code>$ docker rmi $(docker images -q)</code></li></ul><p>Таким образом вы уничтожите все докер-образы и докер-контейнеры на своем компьютере. После этого вам придется собрать заново образы и поднять контейнеры, что сделает следующую сборку медленной (поскольку она не использует данные из кеша). Однако это позволит вам увидеть свои обновления.</p><p>Еще можно указать флаг <code>--no-cache</code> при сборке докер-образа.</p><p>Для удобства можно создать алиасы для запуска докер-комманд в консоли:</p><pre><code>alias dockerrm=’docker rm $(docker ps -aq)’

alias dockerrmi=’docker rmi $(docker images -q)’
</code></pre><h2>Что такое <em>Docker compose</em>, и зачем мне его использовать?</h2><p><img src="./docker-2.png" alt="Docker compose"/></p><p><em><code>Dockerfile</code> можно использовать в сочетании с <code>docker-compose.yml</code> для создания образа.</em></p><p><strong><em>Docker compose</em></strong> удобен тем, что:</p><ul><li><strong><em>Docker compose</em></strong> можно использовать для управления несколькими контейнерами одновременно — что зачастую и происходит. У вас может быть один контейнер для API, второй контейнер для базы данных, третий — для кеша Redis.</li><li>Благодаря <strong><em>Docker compose</em></strong> вы можете запустить все три контейнера одновременно с помощью команды <code>docker-compose up</code>, а затем остановить их вызвав <code>docker-compose down</code>.</li><li><strong><em>Docker compose</em></strong> позволяет перенести большинство опций, которые используется в команде <code>docker run</code> из docker cli, в файл <code>docker-compose.yml</code>.</li></ul><p>Третий пункт, на мой взгляд, самый полезный. Ужасно не удобно запоминать кучу опций docker cli, которые вы будете либо перепечатывать, либо копировать и вставлять снова и снова. Вместо этого вы можете просто поместить их в файл <code>docker-compose.yml</code>, и использовать короткие команды для запуска и остановки контейнеров.</p><p>Кроме того, я заметила, что опции docker cli очень часто меняются разработчиками Докера, в отличие от инструкций в файле <code>docker-compose.yml</code>. Если вы наткнетесь на старую статью по Докеру, то, скорее всего, там будут приведены устаревшие флаги для docker cli.</p><p><strong><em>Docker compose</em></strong> будет полезен, если вам нужно разделить девелоп-образ, который вы используете для разработки, и продакшен-образ, который вы выкладываете для общего использования. Используя флаг <code>-f</code> вы можете вызывать через <code>docker compose</code> разные <code>docker-compose.yml</code> файлы. В случае с разделением образов на девелоп и продакшен, ваши команды будут выглядеть так:</p><pre><code>$ docker-compose -f docker-compose.dev.yml up
$ docker-compose -f docker-compose.prod.yml up
</code></pre><p>Так я могу указать специфические для локальной разработки инструкции в соответствующем докерфайле:</p><pre><code>services:
  &lt;name of my service, like &#x27;server&#x27;&gt;:
  build:
  context: .
  dockerfile: Dockerfile.dev
</code></pre><p>В добавок, если вы используете Docker compose, вы можете создать образ без кеша:</p><pre><code>$ docker-compose build — no-cache
</code></pre><h2>Как войти в запущенный контейнер по ssh?</h2><p>Настраивая докер-образ вам иногда придется заходить по ssh в запущенный докер-контейнер, чтобы посмотреть, что там происходит.</p><p>В зависимости от базового образа, который вы используете (см. строку <code>FROM</code> в вашем докерфайле), у вас может быть установлен или не установлен bash. Если у вас нет bash, вы можете использовать старый добрый sh. С помощью shell вы все равно сможете перемещаться по каталогу, перечислять файлы в каталоге и просматривать файлы с помощью <code>cat</code>.</p><p>Вот так можно посмотреть все запущенные контейнеры:</p><pre><code>$ docker ps
</code></pre><p>Эта команда выведет список всех запущенных контейнеров, их id, и статусы.</p><p>А вот так можно войти в конкретный контейнер:</p><pre><code>$ docker exec -it &lt;container_id&gt; sh
</code></pre><p>В случае, если в контейнере установен bash, вход в контейнер быдет выглядеть так:</p><pre><code>$ docker exec -it &lt;container_id&gt; /bin/bash
</code></pre><p>С помощью docker compose вы можете войти в контейнер с помощью ssh:</p><pre><code>$ docker-compose exec &lt;container_id&gt; sh
</code></pre><h2>Куда поместить код и данные, которые должны храниться вне докер-контейнера? Что делать, если мне нужно уничтожить приложение, но сохранить базу данных?</h2><p>Подсказка: <strong><em>Docker volumes</em></strong>.</p><p>Докер отлично подходит для создания образов (&quot;чертежей&quot; контейнеров, которые размещаются в хранилище) и контейнеров (экземпляров образов). Все, что создается в докер-контейнере, не может измениться во время выполнения.</p><p>Это означает, что докер-контейнеры — не лучшее место для хранения кода вашего приложения или данных из базы данных. Вы столкнетесь с этим, когда будете проходить уроки по Докеру, и заметите, что приходится пересобирать свой контейнер каждый раз, когда меняете код.</p><p>Для кода и данных, которые должны изменяться во время выполнения, лучше использовать инструкцию <code>VOLUMES</code>. Думайте о <strong><em>volume</em></strong>, как о папке, которую вы монтируете в рабочую область <code>WORKDIR</code> докер-контейнера.</p><p><img src="./docker-3.png" alt="Docker volumes"/></p><p><strong><em>Volumes</em></strong> находятся вне докер-образа. Они хорошо подходят для изменяемых вещей, таких как код приложения и данные базы данных.</p><p>Ну а самый простой способ настроить <strong><em>volume</em></strong>, это воспользоваться <strong><em>docker compose</em></strong>. Типичная настройкак <strong><em>volume</em></strong> в файле <code>docker-compose.yml</code> выглядит так:</p><pre><code>volumes:
 — &#x27;.:/src/app&#x27;
 — /src/app/node_modules
</code></pre><p>Описанная выше настройка, означает, что у меня есть пака <code>/src/app</code> в рабочей директории, которую я ранее создала в своем <code>Dockerfile</code>:</p><pre><code>WORKDIR /src/app
RUN npm install
</code></pre><p>Обратите внимание на двоеточие <code>:</code>. Это важно. Слева от двоеточия находится ваша локальная папка по относительному пути. Справа — папка в вашем докер-контейнере (скорее всего, это будет <code>WORKDIR</code>).</p><p>Также обратите внимание, что у вас может быть несколько <strong><em>volumes</em></strong>, и если вы не вставите двоеточие <code>:</code>, то Докер будет рассматривать эту папку в <code>WORKDIR</code> (в данном случае <code>/src/app/node_modules</code>) как часть вашего <strong><em>volume</em></strong>.</p><p>Если вы используюте Node и npm, то строка без двоеточия (<code>/src/app/node_modules</code>) понадобится вам, чтобы ваш код и <code>node_modules</code> находились в одном <code>WORKDIR</code>. <strong><em>Volumes</em></strong> монтируются во время выполнения и скрывают то, что было установлено через <code>RUN</code> в ваш <code>WORKDIR</code> во время сборки.</p><p>Установка <code>node_modules</code> таким образом также ускоряет время сборки, поскольку этот слой (<code>RUN npm install</code>) кешируется.</p><p>Для баз данных, таких как <code>PostgreSQL</code>, часто требуются специальные инструкции для Докера. В примере ниже мы даже не будем указывать <code>Dockerfile</code>, вместо этого мы просто создадтм экземпляр в <code>docker-compose.yml</code>:</p><pre><code>services:
  db:
    # https://hub.docker.com/_/postgres/
    image: postgres:9.6
    restart: always
    volumes:
      — ./pgdata:/var/lib/postgresql/data/pgdata
    ports:
      — ‘5432:5432’
    environment:
      POSTGRES_PASSWORD: &#x27;password&#x27;
      POSTGRES_DB: your_database
      PGDATA: /var/lib/postgresql/data/pgdata
</code></pre><p>Затем в нашем API сервисе мы укажем контейнер <code>postgres</code>:</p><pre><code>services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: my_api_module
    volumes:
      - &#x27;.:/src/app&#x27;
      - /src/app/node_modules
    ports:
      - &#x27;8080:8080&#x27;
    links:
      - db
    depends_on:
      - db
    environment:
      NODE_ENV: &#x27;development&#x27;
      DATABASE_URL: &#x27;postgres://postgres:password@db/your_database&#x27;
</code></pre><h2>В заключение…</h2><p>Надеюсь, эти советы пригодятся вам при разработке докер-образов. Если у вас есть советы и предложения для автора оригинальной статьи, пожалуйста, напишите их в комментариях к статье <a href="https://twg.io/blog/things-i-wish-i-knew-about-docker-before-i-started-using-it/">&quot;Things I Wish I Knew About Docker Before I Started Using It&quot;</a>.</p><hr/><p>Если вам был полезен этот перевод добавляйте меня в друзья <a href="https://github.com/sgromkov/">в Гитхабе</a> и <a href="https://twitter.com/GromkovSergey">в Твиттере</a>.</p><p>И если вам нравится, что я делаю, поддержите меня <a href="https://www.patreon.com/sergey_gromkov">на Патреоне</a> ❤️.</p><p>Советы и замечания оставляйте <a href="https://github.com/sgromkov/gromkov.me/issues">в Issues моего сайта</a>.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Упаковка npm-модулей, которую мы заслужили]]></title>
            <link>https://gromkov.me/blog/2021/02/11/packaging-npm-modules</link>
            <guid>Упаковка npm-модулей, которую мы заслужили</guid>
            <pubDate>Thu, 11 Feb 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Мысли после просмотра доклада Дениса Красновского «Упаковка npm-модулей, которую мы заслужили».]]></description>
            <content:encoded><![CDATA[<p>Мысли после просмотра доклада Дениса Красновского «Упаковка npm-модулей, которую мы заслужили».</p><div class="video"><iframe width="966" height="543" src="https://www.youtube.com/embed/vhHrHdtv7Po?start=746" frameBorder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Ссылка на видео: <a href="https://www.youtube.com/watch?t=746&amp;v=vhHrHdtv7Po">https://www.youtube.com/watch?t=746&amp;v=vhHrHdtv7Po</a></p><p>Денис Красновский рассказал, как уменьшить вес бандла и сэкономить место в <code>node_modules</code>.</p><p>В результате просмотра доклада я создал несколько задач в рабочем проекте на matchtv.ru нацеленных на снижение веса нашего бандла и ускорение его выполнения:</p><ol><li>Убрать <code>propTypes</code> из продакшен-мода через <code>babel-plugin-transform-react-remove-prop-types</code> включив еще в нем опцию <code>removeImport: true</code>;</li><li>Проверить можем ли мы в <code>babel-preset-env</code> использовать <code>loose: true</code>? Не сломается ли IE11?</li><li>Проверить можем ли мы во всех остальных бабель-плагинах включить <code>loose: true</code>? Не сломается ли IE11?</li><li>Проверить размер наших скриптов через <code>import-cost</code>.</li></ol>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[HTML: The Good Parts]]></title>
            <link>https://gromkov.me/blog/2020/03/22/html-the-good-parts</link>
            <guid>HTML: The Good Parts</guid>
            <pubDate>Sun, 22 Mar 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[Мысли после просмотра доклада Вадима Макеева «HTML: The Good Parts».]]></description>
            <content:encoded><![CDATA[<p>Мысли после просмотра доклада Вадима Макеева «HTML: The Good Parts».</p><div class="video"><iframe width="966" height="543" src="https://www.youtube.com/embed/eLlULhNNthI?start=5592" frameBorder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Ссылка на видео: <a href="https://www.youtube.com/watch?v=eLlULhNNthI&amp;t=5592s">https://www.youtube.com/watch?v=eLlULhNNthI&amp;t=5592s</a></p><p>Вадим Макеев покопал спецификацию и рассказал про важные особенности HTML:</p><ul><li>Как можно и как нельзя вкладывать теги друг в друга;</li><li>Как правильно использовать теги <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, <code>&lt;title&gt;</code>, <code>&lt;base&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;style&gt;</code>, <code>&lt;body&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>, многие другие, и про реальное предназначение тега <code>&lt;menu&gt;</code>;</li><li>Инпуты с выпадающим календарем и временем неплохо обновились внешне — теперь не стыдно их использовать в дефолтном виде;</li></ul><p>На <a href="https://matchtv.ru">«Матч ТВ»</a> мы стремимся делать верстку семантичекой, а интерфейсы доступными, поэтому многое из доклада мне было известно. Тем не менее Вадим смог удивить меня несколькими тегами.</p><h2>Хитрый тайтл</h2><p>Никогда ранее не обращал внимание, что содержимое тега <code>&lt;title&gt;</code> не обрабатывается и не рендерится — разрешено вставлять в него html, и этот код отразится на вкладке, прям как код.</p><p>Из-за этой особенности мы рискуем потерять весь свой html, не закрыв <code>&lt;title&gt;</code> — без закрывающего тега всё содержимое страницы бдует считаться браузером содержимым тега <code>&lt;title&gt;</code>, и браузер попытается вставить его во вкладку, вместо того, чтобы отрендерить, как страницу.</p><h2><code>&lt;article&gt;</code> — элемент списка</h2><p>Документация W3Schools, которую я когда-то читал, изучая теги HTML5, дает довольно поверхностное объяснение, как и где нужно использовать этот тег. Я не вдавался в подробности, поэтому все эти годы находился в той группе разработчиков, на которых был нацелен доклад Вадима — я считал, что тег <code>&lt;article&gt;</code> используется для помещения в него полноценных статей, и ничего более.</p><p>Слушая доклад Вадима я был приятно удивлен возможностями тега и теми решениями, которые открылись передо мной. Я уже поставил себе задачу обернуть все элементы списков новостей на <a href="https://matchtv.ru">«Матч ТВ»</a> в <code>&lt;article&gt;</code> и добавить заголовкам статей теги <code>&lt;h4&gt;</code>...<code>&lt;h6&gt;</code>, которые сейчас сделаны обычными дивами. Это улучшит семантику сайта, и увеличит эффективность парсинга контента сайта сео-роботами и браузерами.</p><h2><code>&lt;menu&gt;</code> для списка команд</h2><p>Тег <code>&lt;menu&gt;</code> должен использоваться для вывода на экран списка команд, например, горячих клавиш. И вовсе не для помещения в него меню сайта.</p><p><img src="menu-for-command-list.jpg" alt="Пример блока со списком комманд из доклада Вадима Макеева «HTML: The Good Parts»"/></p><h2>На главной Яндекса семнадцать тегов h1</h2><p><img src="yandex-mainpage-with-17-h1.jpg" alt="Скриншот главной страницы Яндекса с семнадцатью заголовками первого уровня"/></p><h2>Выводы</h2><p>HTML прекрасен. Прекрасен в первую очередь тем, что мы уже сейчас можем делать доступные и удобные интерфейсы не прибегая к помощи джаваскрипта.</p>]]></content:encoded>
        </item>
    </channel>
</rss>